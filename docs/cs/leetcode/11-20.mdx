---
sidebar_position: 2
---

# LeetCode 11-20 解析

## 罗马数字转整数

### 题目描述

罗马数字由七个不同的符号表示：`I`、`V`、`X`、`L`、`C`、`D` 和 `M`。

| 符号 | 值   |
| ---- | --- |
| I    | 1   |
| V    | 5   |
| X    | 10  |
| L    | 50  |
| C    | 100 |
| D    | 500 |
| M    | 1000|

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4。同样地，数字 9 表示为 `IX`。

存在以下六种特殊情况：
- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

### 示例

**示例 1:**
输入: `s = "III"`
输出: `3`

**示例 2:**
输入: `s = "LVIII"`
输出: `58`
解释: `L = 50`, `V= 5`, `III = 3`.

**示例 3:**
输入: `s = "MCMXCIV"`
输出: `1994`
解释: `M = 1000`, `CM = 900`, `XC = 90`, `IV = 4`.

### 解法

**核心原理**

遍历罗马数字字符串，将每个字符映射到其对应的整数值。如果当前字符代表的值小于其后一个字符，则说明是特殊情况（如 `IV`、`IX`），需要减去当前值。否则，加上当前值。

**代码**

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId='leetcode'>
<TabItem value="py" label="Python">

```py
def roman_to_int(s: str) -> int:
    symbol_values = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    total = 0
    i = 0
    while i < len(s):
        # 如果当前字符是最后一个字符，或者当前字符的值不小于下一个字符的值
        if i + 1 == len(s) or symbol_values[s[i]] >= symbol_values[s[i+1]]:
            total += symbol_values[s[i]]
            i += 1
        # 如果当前字符的值小于下一个字符的值
        else:
            total += symbol_values[s[i+1]] - symbol_values[s[i]]
            i += 2
    return total
```

</TabItem>
<TabItem value='c' label="C">

```c
#include <stdio.h>
#include <string.h>
int romanToInt(const char *s) {
    int symbol_values[256] = {0};
    symbol_values['I'] = 1;
    symbol_values['V'] = 5;
    symbol_values['X'] = 10;
    symbol_values['L'] = 50;
    symbol_values['C'] = 100;
    symbol_values['D'] = 500;
    symbol_values['M'] = 1000;

    int total = 0;
    int i = 0;
    int len = strlen(s);
    while (i < len) {
        if (i + 1 < len && symbol_values[(unsigned char)s[i]] < symbol_values[(unsigned char)s[i + 1]]) {
            total += symbol_values[(unsigned char)s[i + 1]] - symbol_values[(unsigned char)s[i]];
            i += 2;
        } else {
            total += symbol_values[(unsigned char)s[i]];
            i += 1;
        }
    }
    return total;
}
```
</TabItem>
<TabItem value="cpp" label="C++">

```cpp
#include <string>
#include <unordered_map>

class Solution {
public:
    int romanToInt(std::string s) {
        std::unordered_map<char, int> symbol_values = {
            {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
            {'C', 100}, {'D', 500}, {'M', 1000}
        };
        int total = 0;
        int i = 0;
        while (i < s.length()) {
            if (i + 1 < s.length() && symbol_values[s[i]] < symbol_values[s[i+1]]) {
                total += symbol_values[s[i+1]] - symbol_values[s[i]];
                i += 2;
            } else {
                total += symbol_values[s[i]];
                i += 1;
            }
        }
        return total;
    }
};
```
</TabItem>
<TabItem value="java" label="Java">

```java
import java.util.Map;

class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> symbolValues = Map.of(
            'I', 1, 'V', 5, 'X', 10, 'L', 50,
            'C', 100, 'D', 500, 'M', 1000
        );
        int total = 0;
        int i = 0;
        while (i < s.length()) {
            if (i + 1 < s.length() && symbolValues.get(s.charAt(i)) < symbolValues.get(s.charAt(i + 1))) {
                total += symbolValues.get(s.charAt(i + 1)) - symbolValues.get(s.charAt(i));
                i += 2;
            } else {
                total += symbolValues.get(s.charAt(i));
                i += 1;
            }
        }
        return total;
    }
}
```

</TabItem>
<TabItem value="csharp" label='C#'>

```csharp
using System.Collections.Generic;

public class Solution {
    public int RomanToInt(string s) {
        var symbolValues = new Dictionary<char, int> {
            {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
            {'C', 100}, {'D', 500}, {'M', 1000}
        };
        int total = 0;
        int i = 0;
        while (i < s.Length) {
            if (i + 1 < s.Length && symbolValues[s[i]] < symbolValues[s[i + 1]]) {
                total += symbolValues[s[i + 1]] - symbolValues[s[i]];
                i += 2;
            } else {
                total += symbolValues[s[i]];
                i++;
            }
        }
        return total;
    }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
var romanToInt = function(s) {
    const symbolValues = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    };
    let total = 0;
    let i = 0;
    while (i < s.length) {
        if (i + 1 < s.length && symbolValues[s[i]] < symbolValues[s[i+1]]) {
            total += symbolValues[s[i+1]] - symbolValues[s[i]];
            i += 2;
        } else {
            total += symbolValues[s[i]];
            i += 1;
        }
    }
    return total;
};
```

</TabItem>
<TabItem value="go" label="Go">

```go
func romanToInt(s string) int {
    symbolValues := map[byte]int{
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000,
    }
    total := 0
    i := 0
    for i < len(s) {
        if i+1 < len(s) && symbolValues[s[i]] < symbolValues[s[i+1]] {
            total += symbolValues[s[i+1]] - symbolValues[s[i]]
            i += 2
        } else {
            total += symbolValues[s[i]]
            i++
        }
    }
    return total
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
use std::collections::HashMap;

pub fn roman_to_int(s: &str) -> i32 {
    let symbol_values: HashMap<char, i32> = [
        ('I', 1), ('V', 5), ('X', 10), ('L', 50),
        ('C', 100), ('D', 500), ('M', 1000)
    ].iter().cloned().collect();

    let mut total = 0;
    let mut i = 0;
    while i < s.len() {
        if i + 1 < s.len() && symbol_values[&s.chars().nth(i).unwrap()] < symbol_values[&s.chars().nth(i + 1).unwrap()] {
            total += symbol_values[&s.chars().nth(i + 1).unwrap()] - symbol_values[&s.chars().nth(i).unwrap()];
            i += 2;
        } else {
            total += symbol_values[&s.chars().nth(i).unwrap()];
            i += 1;
        }
    }
    total
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
fun romanToInt(s: String): Int {
    val symbolValues = mapOf(
        'I' to 1, 'V' to 5, 'X' to 10, 'L' to 50,
        'C' to 100, 'D' to 500, 'M' to 1000
    )
    var total = 0
    var i = 0
    while (i < s.length) {
        if (i + 1 < s.length && symbolValues[s[i]]!! < symbolValues[s[i + 1]]!!) {
            total += symbolValues[s[i + 1]]!! - symbolValues[s[i]]!!
            i += 2
        } else {
            total += symbolValues[s[i]]!!
            i++
        }
    }
    return total
}
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts
function romanToInt(s: string): number {
    const symbolValues: { [key: string]: number } = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    };
    let total = 0;
    let i = 0;
    while (i < s.length) {
        if (i + 1 < s.length && symbolValues[s[i]] < symbolValues[s[i + 1]]) {
            total += symbolValues[s[i + 1]] - symbolValues[s[i]];
            i += 2;
        } else {
            total += symbolValues[s[i]];
            i++;
        }
    }
    return total;
}
```
</TabItem>
</Tabs>

#### 代码解析

1. `symbol_values` 字典用于存储罗马数字符号及其对应的整数值。
2. 使用 `while` 循环遍历字符串 `s`。
3. `if (i + 1 == len(s) or symbol_values[s[i]] >= symbol_values[s[i+1]])` 检查当前字符是否是最后一个字符，或者当前字符的值不小于下一个字符的值。
    - `total += symbol_values[s[i]] -symbol_values[s[i+1]]` 处理特殊情况，如 `IV` 或 `IX`。`total += 2` 处理正常情况，将当前字符的值加到总和中。
    - `total += symbol_values[s[i]]` 处理正常情况，将当前字符的值加到总和中。`i++` 使索引前进到下一个字符。
4. `return total` 返回最终的整数值。

#### 算法分析

- **时间复杂度**: O(n)，其中 n 是字符串的长度。我们只需要遍历一次字符串。
- **空间复杂度**: O(1)，我们只用了一个固定大小的哈希表来存储符号和值的映射，其空间不随输入字符串的长度而改变。

## 最长公共前缀

### 题目描述

编写一个函数，找出字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

- 前缀：例如 `flow` 是 `flower` 和 `flowing` 的前缀。
- 最长公共前缀：例如 `fl` 是 `flower` 和 `flowing` 的最长公共前缀。

### 示例

输入: `["flower","flow","flight"]`
输出: `"fl"`

输入: `["dog","racecar","car"]`
输出: `""`

### 解法

**核心原理**

我们可以通过逐个比较字符串的字符来找到最长公共前缀。首先假设第一个字符串是最长公共前缀，然后与其他字符串逐一比较，更新最长公共前缀。

1. 找到最短的字符串。
2. 遍历所有字符串，检查它们是否以这个候选前缀开始。
3. 如果发现某个字符串不以候选前缀开始，就将候选前缀缩短一个字符，继续检查。
4. 直到找到一个公共前缀，或者候选前缀为空。

**代码**

<Tabs groupId='leetcode'>
<TabItem value="py" label="Python">

```py
def longest_common_prefix(strs: list[str]) -> str:
    if not strs:
        return ""
    # Assume the first string is the prefix
    prefix = strs[0]
    for i in range(1, len(strs)):
        # Shorten the prefix until it's a prefix of the current string
        while not strs[i].startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

</TabItem>
<TabItem value='c' label="C">

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

char* longestCommonPrefix(char** strs, int strsSize) {
    if (strsSize == 0) {
        char* res = (char*)malloc(1);
        res[0] = '\0';
        return res;
    }

    int prefix_len = strlen(strs[0]);
    for (int i = 1; i < strsSize; i++) {
        int j = 0;
        // Compare characters of the first string with the current string
        while (j < prefix_len && j < strlen(strs[i]) && strs[0][j] == strs[i][j]) {
            j++;
        }
        prefix_len = j; // Update the length of the common prefix
    }

    char* res = (char*)malloc(prefix_len + 1);
    strncpy(res, strs[0], prefix_len);
    res[prefix_len] = '\0';
    return res;
}
```
</TabItem>
<TabItem value="cpp" label="C++">

```cpp
#include <string>
#include <vector>

class Solution {
public:
    std::string longestCommonPrefix(std::vector<std::string>& strs) {
        if (strs.empty()) {
            return "";
        }
        std::string prefix = strs[0];
        for (int i = 1; i < strs.size(); ++i) {
            while (strs[i].find(prefix) != 0) {
                prefix = prefix.substr(0, prefix.length() - 1);
                if (prefix.empty()) {
                    return "";
                }
            }
        }
        return prefix;
    }
};
```
</TabItem>
<TabItem value="java" label="Java">

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return "";
                }
            }
        }
        return prefix;
    }
}
```

</TabItem>
<TabItem value="csharp" label='C#'>

```csharp
public class Solution {
    public string LongestCommonPrefix(string[] strs) {
        if (strs == null || strs.Length == 0) {
            return "";
        }
        string prefix = strs[0];
        for (int i = 1; i < strs.Length; i++) {
            while (strs[i].IndexOf(prefix) != 0) {
                prefix = prefix.Substring(0, prefix.Length - 1);
                if (string.IsNullOrEmpty(prefix)) {
                    return "";
                }
            }
        }
        return prefix;
    }
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if (!strs || strs.length === 0) {
        return "";
    }
    let prefix = strs[0];
    for (let i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix) !== 0) {
            prefix = prefix.substring(0, prefix.length - 1);
            if (prefix === "") {
                return "";
            }
        }
    }
    return prefix;
};
```

</TabItem>
<TabItem value="go" label="Go">

```go
import "strings"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
            if prefix == "" {
                return ""
            }
        }
    }
    return prefix
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
pub fn longest_common_prefix(strs: Vec<String>) -> String {
    if strs.is_empty() {
        return String::new();
    }
    let mut prefix = strs[0].clone();
    for s in strs.iter().skip(1) {
        while !s.starts_with(&prefix) {
            prefix.pop();
            if prefix.is_empty() {
                return String::new();
            }
        }
    }
    prefix
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
fun longestCommonPrefix(strs: Array<String>): String {
    if (strs.isEmpty()) return ""
    var prefix = strs[0]
    for (i in 1 until strs.size) {
        while (!strs[i].startsWith(prefix)) {
            prefix = prefix.substring(0, prefix.length - 1)
            if (prefix.isEmpty()) return ""
        }
    }
    return prefix
}
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts
function longestCommonPrefix(strs: string[]): string {
    if (!strs || strs.length === 0) {
        return "";
    }
    let prefix = strs[0];
    for (let i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix) !== 0) {
            prefix = prefix.substring(0, prefix.length - 1);
            if (prefix === "") {
                return "";
            }
        }
    }
    return prefix;
};
```
</TabItem>
</Tabs>

**代码解析**

1. `if not strs: return ""` 检查字符串数组是否为空，如果为空，直接返回空字符串。
2. `prefix = strs[0]` 将第一个字符串作为初始前缀。
3. 遍历字符串数组，从第二个字符串开始：
   - `while strs[i].find(prefix) != 0:` 如果当前字符串不以前缀开头，则逐渐缩短前缀。
   - `prefix = prefix.substr(0, prefix.length() - 1)` 将前缀缩短一个字符。
   - `if prefix.empty(): return ""` 如果前缀为空，则返回空字符串。
4. 返回找到的最长公共前缀。

**算法分析**

- 时间复杂度：O(S)，其中 S 是所有字符串中字符数量的总和。在最坏的情况下，我们需要比较每个字符。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。