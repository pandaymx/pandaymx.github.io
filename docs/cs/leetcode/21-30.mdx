---
sidebar_position: 3
---

# LeetCode 21-30 解析

## 21. 合并两个有序链表

### 题目描述

给定两个已排序的链表，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。返回合并链表。

### 示例

输入：list1 = [1,2,4]，list2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：list1 = []，list2 = [0]
输出：[0]

输入：list1 = []，list2 = []
输出：[]

### 解法

**核心原理**

通过双指针遍历两个链表，比较当前节点的值，将较小的节点连接到新链表中，直到遍历完其中一个链表。最后，将另一个链表的剩余部分连接到新链表的末尾。

**代码**

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId='leetcode'>
<TabItem value="py" label="Python">

```py
def merge_two_lists(list1, list2):
    # 创建一个虚拟头节点，简化操作
    dummy = ListNode(0)
    current = dummy
    
    # 遍历两个链表，比较节点值
    while list1 and list2:
        if list1.val <= list2.val:
            current.next = list1
            list1 = list1.next
        else:
            current.next = list2
            list2 = list2.next
        current = current.next
    
    # 将剩余节点连接到新链表
    current.next = list1 or list2
    
    # 返回合并后的链表（跳过虚拟头节点）
    return dummy.next
```

</TabItem>
<TabItem value="c" label="C">

```c
struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    // 创建虚拟头节点
    struct ListNode dummy;
    struct ListNode* current = &dummy;
    dummy.next = NULL;
    
    // 遍历两个链表，比较节点值
    while (list1 != NULL && list2 != NULL) {
        if (list1->val <= list2->val) {
            current->next = list1;
            list1 = list1->next;
        } else {
            current->next = list2;
            list2 = list2->next;
        }
        current = current->next;
    }
    
    // 将剩余节点连接到新链表
    current->next = (list1 != NULL) ? list1 : list2;
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next;
}
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    // 创建虚拟头节点
    ListNode dummy(0);
    ListNode* current = &dummy;
    
    // 遍历两个链表，比较节点值
    while (list1 && list2) {
        if (list1->val <= list2->val) {
            current->next = list1;
            list1 = list1->next;
        } else {
            current->next = list2;
            list2 = list2->next;
        }
        current = current->next;
    }
    
    // 将剩余节点连接到新链表
    current->next = list1 ? list1 : list2;
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next;
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    // 创建虚拟头节点
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    // 遍历两个链表，比较节点值
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // 将剩余节点连接到新链表
    current.next = (list1 != null) ? list1 : list2;
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next;
}
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp
public ListNode MergeTwoLists(ListNode list1, ListNode list2) {
    // 创建虚拟头节点
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    // 遍历两个链表，比较节点值
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // 将剩余节点连接到新链表
    current.next = (list1 != null) ? list1 : list2;
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next;
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
function mergeTwoLists(list1, list2) {
    // 创建虚拟头节点
    const dummy = new ListNode(0);
    let current = dummy;
    
    // 遍历两个链表，比较节点值
    while (list1 && list2) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // 将剩余节点连接到新链表
    current.next = list1 || list2;
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next;
}
```

</TabItem>
<TabItem value="go" label="Go">

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    // 创建虚拟头节点
    dummy := &ListNode{}
    current := dummy
    
    // 遍历两个链表，比较节点值
    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            current.Next = list1
            list1 = list1.Next
        } else {
            current.Next = list2
            list2 = list2.Next
        }
        current = current.Next
    }
    
    // 将剩余节点连接到新链表
    if list1 != nil {
        current.Next = list1
    } else {
        current.Next = list2
    }
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.Next
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
pub fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    // 创建虚拟头节点
    let mut dummy = ListNode::new(0);
    let mut current = &mut dummy;
    
    // 使用可变引用操作两个链表
    let mut list1 = list1;
    let mut list2 = list2;
    
    // 遍历两个链表，比较节点值
    while let (Some(node1), Some(node2)) = (list1.as_ref(), list2.as_ref()) {
        if node1.val <= node2.val {
            current.next = list1.take();
            current = current.next.as_mut().unwrap();
            list1 = current.next.take();
        } else {
            current.next = list2.take();
            current = current.next.as_mut().unwrap();
            list2 = current.next.take();
        }
    }
    
    // 将剩余节点连接到新链表
    current.next = list1.or(list2);
    
    // 返回合并后的链表（跳过虚拟头节点）
    dummy.next
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {
    // 创建虚拟头节点
    val dummy = ListNode(0)
    var current: ListNode? = dummy
    var list1 = list1
    var list2 = list2
    
    // 遍历两个链表，比较节点值
    while (list1 != null && list2 != null) {
        if (list1.`val` <= list2.`val`) {
            current?.next = list1
            list1 = list1.next
        } else {
            current?.next = list2
            list2 = list2.next
        }
        current = current?.next
    }
    
    // 将剩余节点连接到新链表
    current?.next = list1 ?: list2
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next
}
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts
function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {
    // 创建虚拟头节点
    const dummy = new ListNode(0);
    let current: ListNode | null = dummy;
    
    // 遍历两个链表，比较节点值
    while (list1 && list2) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // 将剩余节点连接到新链表
    current.next = list1 || list2;
    
    // 返回合并后的链表（跳过虚拟头节点）
    return dummy.next;
}
```

</TabItem>
</Tabs>

**代码解析**

- `dummy = ListNode(0)`：创建一个虚拟头节点，简化链表操作。
- `current = dummy`：当前节点指针，初始指向虚拟头节点。
- `while list1 and list2:`: 遍历两个链表，比较节点值
    - `current.next = list1`：将较小的节点连接到新链表。
    - `list1 = list1.next`：移动到下一个节点。
    - `current = current.next`：更新当前节点指针。
- `current.next = list1 || list2`：将剩余节点连接到新链表。
- `return dummy.next`：返回合并后的链表（跳过虚拟头节点）。

:::tip[if 条件判断]

关于 if 条件中只写了一条的原因是两个功能完全一样。

:::

**算法分析**

- 时间复杂度：O(m + n)，其中 m 和 n 分别是两个链表的长度。我们只需遍历一次两个链表。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 26. 删除有序数组中的重复项

### 题目描述

一个非严格递增排列的数组 `nums`，原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k`，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums`，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。
- `nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k`。

:::tip[原地删除]

原地操作需要在原始数组上进行修改，不创建新的数组存放结果。

:::

### 示例

输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2，并且原数组 nums 的前两个元素被修改为 1, 2。不需要考虑数组中超出新长度后面的元素。

输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5，并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。不需要考虑数组中超出新长度后面的元素。

### 解法

**核心原理**

使用双指针技巧。一个指针用于遍历数组（快指针），另一个指针用于指向当前不重复元素应该放置的位置（慢指针）。当快指针遇到一个与前一个元素不同的元素时，将其值复制到慢指针位置，并将慢指针前移。

**代码**

<Tabs groupId='leetcode'>
<TabItem value="py" label="Python">

```py
def remove_duplicates(nums):
    # 处理空数组或只有一个元素的情况
    if len(nums) <= 1:
        return len(nums)
    
    # 慢指针，指向当前不重复元素应该放置的位置
    slow = 1
    
    # 快指针，用于遍历数组
    for fast in range(1, len(nums)):
        # 如果当前元素与前一个元素不同
        if nums[fast] != nums[fast - 1]:
            # 将当前元素复制到慢指针位置
            nums[slow] = nums[fast]
            # 慢指针前移
            slow += 1
    
    # 返回不重复元素的个数
    return slow
```

</TabItem>
<TabItem value="c" label="C">

```c
int removeDuplicates(int* nums, int numsSize) {
    // 处理空数组或只有一个元素的情况
    if (numsSize <= 1) {
        return numsSize;
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    int slow = 1;
    
    // 快指针，用于遍历数组
    for (int fast = 1; fast < numsSize; fast++) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] != nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow++;
        }
    }
    
    // 返回不重复元素的个数
    return slow;
}
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp
int removeDuplicates(vector<int>& nums) {
    // 处理空数组或只有一个元素的情况
    if (nums.size() <= 1) {
        return nums.size();
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    int slow = 1;
    
    // 快指针，用于遍历数组
    for (int fast = 1; fast < nums.size(); fast++) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] != nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow++;
        }
    }
    
    // 返回不重复元素的个数
    return slow;
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public int removeDuplicates(int[] nums) {
    // 处理空数组或只有一个元素的情况
    if (nums.length <= 1) {
        return nums.length;
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    int slow = 1;
    
    // 快指针，用于遍历数组
    for (int fast = 1; fast < nums.length; fast++) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] != nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow++;
        }
    }
    
    // 返回不重复元素的个数
    return slow;
}
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp
public int RemoveDuplicates(int[] nums) {
    // 处理空数组或只有一个元素的情况
    if (nums.Length <= 1) {
        return nums.Length;
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    int slow = 1;
    
    // 快指针，用于遍历数组
    for (int fast = 1; fast < nums.Length; fast++) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] != nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow++;
        }
    }
    
    // 返回不重复元素的个数
    return slow;
}
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
function removeDuplicates(nums) {
    // 处理空数组或只有一个元素的情况
    if (nums.length <= 1) {
        return nums.length;
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    let slow = 1;
    
    // 快指针，用于遍历数组
    for (let fast = 1; fast < nums.length; fast++) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] !== nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow++;
        }
    }
    
    // 返回不重复元素的个数
    return slow;
}
```

</TabItem>
<TabItem value="go" label="Go">

```go
func removeDuplicates(nums []int) int {
    // 处理空数组或只有一个元素的情况
    if len(nums) <= 1 {
        return len(nums)
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    slow := 1
    
    // 快指针，用于遍历数组
    for fast := 1; fast < len(nums); fast++ {
        // 如果当前元素与前一个元素不同
        if nums[fast] != nums[fast-1] {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast]
            // 慢指针前移
            slow++
        }
    }
    
    // 返回不重复元素的个数
    return slow
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
pub fn remove_duplicates(nums: &mut Vec<i32>) -> i32 {
    // 处理空数组或只有一个元素的情况
    if nums.len() <= 1 {
        return nums.len() as i32;
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    let mut slow = 1;
    
    // 快指针，用于遍历数组
    for fast in 1..nums.len() {
        // 如果当前元素与前一个元素不同
        if nums[fast] != nums[fast - 1] {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow += 1;
        }
    }
    
    // 返回不重复元素的个数
    slow as i32
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
fun removeDuplicates(nums: IntArray): Int {
    // 处理空数组或只有一个元素的情况
    if (nums.size <= 1) {
        return nums.size
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    var slow = 1
    
    // 快指针，用于遍历数组
    for (fast in 1 until nums.size) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] != nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast]
            // 慢指针前移
            slow++
        }
    }
    
    // 返回不重复元素的个数
    return slow
}
```

</TabItem>
<TabItem value="ts" label="TypeScript">

```ts
function removeDuplicates(nums: number[]): number {
    // 处理空数组或只有一个元素的情况
    if (nums.length <= 1) {
        return nums.length;
    }
    
    // 慢指针，指向当前不重复元素应该放置的位置
    let slow = 1;
    
    // 快指针，用于遍历数组
    for (let fast = 1; fast < nums.length; fast++) {
        // 如果当前元素与前一个元素不同
        if (nums[fast] !== nums[fast - 1]) {
            // 将当前元素复制到慢指针位置
            nums[slow] = nums[fast];
            // 慢指针前移
            slow++;
        }
    }
    
    // 返回不重复元素的个数
    return slow;
}
```

</TabItem>
</Tabs>

**代码解析**

- `if (len(nums) <= 1)`：处理边界情况，空数组或只有一个元素的数组不需要处理。
- `slow = 1`：慢指针初始化为1，因为第一个元素肯定是要保留的。
- `for fast in range(1, len(nums))`：快指针从索引1开始遍历数组。
- `if nums[fast] != nums[fast - 1]`：判断当前元素是否与前一个元素不同。
- `nums[slow] = nums[fast]`：将不重复的元素复制到慢指针位置。
- `slow += 1`：慢指针前移，为下一个不重复元素准备位置。
- `return slow`：返回不重复元素的个数。

**算法分析**

- 时间复杂度：O(n)，其中 n 是数组的长度。我们只需遍历一次数组。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。